<!DOCTYPE html>
<html lang="ja">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>stargazer</title>
 <style>
* { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"; padding: 16px; line-height: 1.3; font-weight: normal; background-color: #f7f7f7; color: #333; } h4 { font-size: 1.25rem; color: #555; margin-bottom: .5rem; } p { font-size: .9rem; color: #666; margin-bottom: .25rem; } a { color: #007bff; text-decoration: none; } a:hover { text-decoration: underline; } .container { max-width: 600px; margin-left: .5rem; margin-right: auto; padding: .5rem; } @media (max-width: 767px) { .container { max-width: 100%; padding: 8px; margin: 0; } } label { font-size: .9rem; color: #666; } input[type="text"], textarea { border: 1px solid #ccc; padding: 6px; border-radius: 4px; margin: 4px; } button { border: none; padding: 6px 12px; border-radius: 20px; color: white; cursor: pointer; font-weight: bold; transition: background-color .2s; background-color: #aaa; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒœã‚¿ãƒ³è‰² */ } #apply-pubkey-for-reactions { background-color: #ff99cc; } #apply-pubkey-for-reactions:hover { background-color: #ff66b2; } button#load-more { background-color: #66b3ff; } button#load-more:hover { background-color: #4da6ff; } button#load-more.loading { visibility: hidden; } hr { border: none; border-top: 0px solid #ccc; margin: 0px 0px 0px 0px; } ul#timeline { list-style: none; padding: 0; margin: 8px 0; border-top: 1px solid #eee; } #timeline li { list-style: none !important; } li.event { word-break: break-all; padding: 6px 0; border-bottom: 1px solid #eee; } li.event-reaction { background-color: #f7f7f7; } .original-post-preview { margin: 0.5rem 0.5rem 0rem 0.5rem; background-color: #f7f7f7; border-left: 0rem solid #f7f7f7; font-size: 0.9em; font-style: normal; max-height: 100px; overflow: hidden; text-overflow: ellipsis; padding: 1px; border-radius: 4px; } .original-post-preview.loading { color: #888; } .nostr-ref { background-color: #f7f7f7; padding: 1px 2px; border-radius: 4px; } a.pubkey-ref { font-weight: bold; color: #555; text-decoration: none; } a.pubkey-ref:hover { text-decoration: underline; } time { color: #888; }
</style>
</head>
<body>
<div id="header-placeholder"></div>
 <h4>stargazer</h4><p style="font-size:1rem;">ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯ã€ç‰¹å®šã®å…¬é–‹éµãŒå—ã‘å–ã£ãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆâ˜†ï¼‰ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã€‚</p><div><label for="target-hex-pubkey">å…¬é–‹éµï¼ˆnpubï¼‰</label><input id="target-hex-pubkey" type="text" placeholder="npub or hex or NIP-05"><button id="apply-pubkey-for-reactions">è¦‹ã‚‹</button></div>
 <hr/>
 <ul id="timeline"></ul>
 <button type="button" id="load-more" class="loading">ã‚‚ã£ã¨è¦‹ã‚‹</button>
 <script src="https://unpkg.com/nostr-tools/lib/nostr.bundle.js"></script>
Â <script>
Â  // === æ±ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ===
Â  function getLanguage() {
Â  Â  return (window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage).substring(0, 2);
Â  }
Â 
Â  function formatTimestamp(date) {
Â  Â  return String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0");
Â  }
Â 
Â  function findTagWithValue(tags, name, value, extraPred) {
Â  Â  for (const tag of tags) {
Â  Â  Â  if (tag[0] === name && tag[1] === value && (extraPred ? extraPred(tag) : true)) {
Â  Â  Â  Â  return tag;
Â  Â  Â  }
Â  Â  }
Â  Â  return undefined;
Â  }
Â 
Â  function baseEventView() {
Â  Â  const li = document.createElement("li");
Â  Â  li.classList.add("event");
Â  Â  return li;
Â  }
Â 
Â  function externalLink(url, text) {
Â  Â  const a = document.createElement("a");
Â  Â  a.href = url;
Â  Â  a.target = "_blank";
Â  Â  a.rel = "noreferrer";
Â  Â  a.textContent = text;
Â  Â  return a;
Â  }
Â 
Â  function timestampView(unixtime) {
Â  Â  const ts = new Date(unixtime * 1000);
Â  Â  const timeElem = document.createElement("time");
Â  Â  timeElem.setAttribute("datetime", ts.toISOString());
Â  Â  timeElem.textContent = "[" + formatTimestamp(ts) + "]";
Â  Â  return timeElem;
Â  }
Â 
Â  // === ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨è¡¨ç¤ºã®æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ ===
Â  const profileCache = {};
Â  const pubkeyElements = {};
Â 
Â  function getDisplayName(pubkey) {
Â  Â  if (profileCache[pubkey] && profileCache[pubkey].name) {
Â  Â  Â  return profileCache[pubkey].name;
Â  Â  }
Â  Â  return pubkey.substring(0, 8);
Â  }
Â 
Â  function updatePubkeyView(pubkey) {
Â  Â  const displayName = getDisplayName(pubkey);
Â  Â  if (pubkeyElements[pubkey]) {
Â  Â  Â  pubkeyElements[pubkey].forEach(elem => {
Â  Â  Â  Â  elem.textContent = displayName;
Â  Â  Â  });
Â  Â  }
Â  }
Â 
Â  function pubkeyView(pubkey) {
Â  Â  const npub = window.NostrTools.nip19.npubEncode(pubkey);
Â  Â  const displayName = getDisplayName(pubkey);
Â  Â  const a = externalLink("https://njump.me/" + npub, displayName);
Â  Â  a.classList.add("pubkey-ref");
Â 
Â  Â  if (!pubkeyElements[pubkey]) {
Â  Â  Â  pubkeyElements[pubkey] = [];
Â  Â  }
Â  Â  pubkeyElements[pubkey].push(a);
Â 
Â  Â  return a;
Â  }
Â 
Â  function metadataView(nostrEv) {
Â  Â  const view = document.createElement("span");
Â  Â  view.appendChild(timestampView(nostrEv.created_at));
Â  Â  view.appendChild(document.createTextNode(" "));
Â  Â  view.appendChild(pubkeyView(nostrEv.pubkey));
Â  Â  view.appendChild(document.createTextNode(" > "));
Â  Â  return view;
Â  }
Â 
Â  // === ã‚¤ãƒ™ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨å…ƒã®æŠ•ç¨¿è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ ===
Â  const eventCache = {};
Â  const eventsToFetch = new Set();
Â  let eventFetchTimeout = null;
Â 
Â  // å…ƒã®æŠ•ç¨¿å†…å®¹ã‚’å–å¾—ã—ã€è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
Â  function fetchAndDisplayOriginalPost(reactedEventId) {
Â  Â  if (eventCache[reactedEventId]) {
Â  Â  Â  updateOriginalPostView(reactedEventId);
Â  Â  Â  return;
Â  Â  }
Â 
Â  Â  if (!eventsToFetch.has(reactedEventId)) {
Â  Â  Â  eventsToFetch.add(reactedEventId);
Â  Â  Â  scheduleEventFetch();
Â  Â  }
Â  }
Â 
Â  // å–å¾—ã—ãŸå…ƒã®æŠ•ç¨¿ã‚’DOMã«åæ˜ ã™ã‚‹é–¢æ•°
Â  function updateOriginalPostView(reactedEventId) {
Â  Â  const elementsToUpdate = document.querySelectorAll(`.original-post-preview[data-event-id="${reactedEventId}"]`);
Â  Â  elementsToUpdate.forEach(elem => {
Â  Â  Â  const originalEvent = eventCache[reactedEventId];
Â  Â  Â  if (originalEvent) {
Â  Â  Â  Â  elem.textContent = originalEvent.content.substring(0, 150) + (originalEvent.content.length > 150 ? '...' : '');
Â  Â  Â  Â  elem.classList.remove('loading');
Â  Â  Â  Â  elem.classList.remove('nostr-ref');
Â  Â  Â  }
Â  Â  });
Â  }
Â 
Â  // ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã¾ã¨ã‚ã¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆã™ã‚‹ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©
Â  function scheduleEventFetch() {
Â  Â  if (eventFetchTimeout) {
Â  Â  Â  clearTimeout(eventFetchTimeout);
Â  Â  }
Â  Â  eventFetchTimeout = setTimeout(() => {
Â  Â  Â  if (eventsToFetch.size > 0 && reactionWSs.length > 0) {
Â  Â  Â  Â  const eventIds = Array.from(eventsToFetch);
Â  Â  Â  Â  const subId = "FETCH_ORIGINAL_EVENTS_" + Date.now();
Â  Â  Â  Â  for (const ws of reactionWSs) {
Â  Â  Â  Â  Â  if (ws.readyState === WebSocket.OPEN) {
Â  Â  Â  Â  Â  Â  ws.send(JSON.stringify(["REQ", subId, {
Â  Â  Â  Â  Â  Â  Â  kinds: [1, 6],
Â  Â  Â  Â  Â  Â  Â  ids: eventIds,
Â  Â  Â  Â  Â  Â  Â  limit: eventIds.length
Â  Â  Â  Â  Â  Â  }]));
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  eventFetchTimeout = null;
Â  Â  }, 100);
Â  }
Â 
Â  // Kind:7 ã‚¤ãƒ™ãƒ³ãƒˆã®è¡¨ç¤ºå‡¦ç†
Â  function reactionEventView(nostrEv) {
Â  Â  const view = baseEventView();
Â  Â  view.id = nostrEv.id;
Â  Â  view.classList.add("event-reaction");
Â 
Â  Â  view.appendChild(metadataView(nostrEv));
Â 
Â  Â  let reactionContent = nostrEv.content;
Â  Â  if (reactionContent === "+") {
Â  Â  Â  reactionContent = "â˜†";
Â  Â  } else if (reactionContent === "") {
Â  Â  Â  reactionContent = "ğŸ‘";
Â  Â  } else if (reactionContent === undefined) {
Â  Â  Â  reactionContent = "ğŸ‘";
Â  Â  }
Â 
Â  Â  const contentSpan = document.createElement("span");
Â  Â  contentSpan.textContent = " " + reactionContent + " ";
Â  Â  view.appendChild(contentSpan);
Â 
Â  Â  let reactedEventId;
Â  Â  for (const tag of nostrEv.tags) {
Â  Â  Â  if (tag[0] === "e" && typeof tag[1] === "string") {
Â  Â  Â  Â  reactedEventId = tag[1];
Â  Â  Â  Â  break;
Â  Â  Â  }
Â  Â  }
Â 
Â  Â  if (reactedEventId) {
Â  Â  Â  const nevent = window.NostrTools.nip19.neventEncode({
Â  Â  Â  Â  id: reactedEventId,
Â  Â  Â  Â  relays: ["wss://relay.nostr.band"]
Â  Â  Â  });
Â  Â  Â  const link = externalLink(`https://njump.me/${nevent}`, `å…ƒã®æŠ•ç¨¿ã‚’è¦‹ã‚‹`);
Â  Â  Â  view.appendChild(document.createTextNode(" "));
Â  Â  Â  view.appendChild(link);
Â  Â  }
Â 
Â  Â  const originalPostContainer = document.createElement('div');
Â  Â  originalPostContainer.classList.add('original-post-preview');
Â  Â  originalPostContainer.id = `original-post-${nostrEv.id}`;
Â  Â  originalPostContainer.setAttribute('data-event-id', reactedEventId);
Â  Â  view.appendChild(document.createElement('br'));
Â  Â  view.appendChild(originalPostContainer);
Â 
Â  Â  if (reactedEventId) {
Â  Â  Â  originalPostContainer.textContent = `å…ƒã®æŠ•ç¨¿ã‚’å–å¾—ä¸­... (nostr:${reactedEventId.substring(0, 8)}...)`;
Â  Â  Â  originalPostContainer.classList.add('loading');
Â  Â  Â  originalPostContainer.classList.add('nostr-ref');
Â  Â  Â  fetchAndDisplayOriginalPost(reactedEventId);
Â  Â  } else {
Â  Â  Â  originalPostContainer.textContent = "å…ƒã®æŠ•ç¨¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚";
Â  Â  Â  originalPostContainer.classList.add('nostr-ref');
Â  Â  }
Â  Â  return view;
Â  }
Â 
Â  // ==== ãƒ¡ã‚¤ãƒ³ã®ãƒ­ã‚¸ãƒƒã‚¯éƒ¨åˆ† ====
Â  const timeline = document.getElementById("timeline");
Â  if (timeline === null) {
Â  Â  throw new Error("no #timeline");
Â  }
Â 
Â  const targetHexPubkeyInput = document.getElementById("target-hex-pubkey");
Â  const applyPubkeyForReactionsButton = document.getElementById("apply-pubkey-for-reactions");
Â 
Â  // ãƒªãƒ¬ãƒ¼URLã‚’å›ºå®š
Â  const RELAY_URLS = ["wss://relay.nostr.band", "wss://relay.damus.io"];
Â 
Â  const reactionWSs = [];
Â  const seenEventIds = new Set();
Â 
Â  let oldestCreatedAt = Number.MAX_VALUE;
Â  let currentTargetPubkeyForReactions = undefined;
Â 
Â  const REACTION_SUB_ID = "motherfucking-reaction-sub";
Â  const PROFILE_SUB_ID_REACTIONS = "motherfucking-profile-sub-reactions";
Â  const MORE_REACTIONS_SUB_ID = "motherfucking-more-reactions-sub";
Â 
Â  const pubkeysToFetchProfile = new Set();
Â  let profileFetchTimeout = null;
Â 
Â  // === ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¡¨ç¤ºã®ãƒªã‚»ãƒƒãƒˆå‡¦ç† ===
Â  function clearTimeline() {
Â  Â  while (timeline.firstChild) {
Â  Â  Â  timeline.removeChild(timeline.firstChild);
Â  Â  }
Â  Â  oldestCreatedAt = Number.MAX_VALUE;
Â  Â  seenEventIds.clear();
Â  }
Â 
Â  // === å—ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ¡ã‚¤ãƒ³å‡¦ç† ===
Â  function onEvent(nostrEv) {
Â  Â  // kind:0 ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
Â  Â  if (nostrEv.kind === 0) {
Â  Â  Â  try {
Â  Â  Â  Â  const metadata = JSON.parse(nostrEv.content);
Â  Â  Â  Â  profileCache[nostrEv.pubkey] = {
Â  Â  Â  Â  Â  name: metadata.name || nostrEv.pubkey.substring(0, 8),
Â  Â  Â  Â  Â  picture: metadata.picture,
Â  Â  Â  Â  Â  about: metadata.about
Â  Â  Â  Â  };
Â  Â  Â  Â  updatePubkeyView(nostrEv.pubkey);
Â  Â  Â  Â  pubkeysToFetchProfile.delete(nostrEv.pubkey);
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  console.error("Failed to parse kind 0 content:", e);
Â  Â  Â  }
Â  Â  Â  return;
Â  Â  }
Â 
Â  Â  // kind:1, 6 å…ƒã®æŠ•ç¨¿ã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
Â  Â  if (nostrEv.kind === 1 || nostrEv.kind === 6) {
Â  Â  Â  eventCache[nostrEv.id] = nostrEv;
Â  Â  Â  eventsToFetch.delete(nostrEv.id);
Â  Â  Â  updateOriginalPostView(nostrEv.id);
Â  Â  Â  return;
Â  Â  }
Â 
Â  Â  // kind:7 ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
Â  Â  if (nostrEv.kind === 7) {
Â  Â  Â  if (seenEventIds.has(nostrEv.id)) {
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  seenEventIds.add(nostrEv.id);
Â  Â  Â  const newReactionView = reactionEventView(nostrEv);
Â  Â  Â  timeline.appendChild(newReactionView);
Â  Â  Â  oldestCreatedAt = Math.min(oldestCreatedAt, nostrEv.created_at);
Â 
Â  Â  Â  if (!profileCache[nostrEv.pubkey] && !pubkeysToFetchProfile.has(nostrEv.pubkey)) {
Â  Â  Â  Â  pubkeysToFetchProfile.add(nostrEv.pubkey);
Â  Â  Â  Â  scheduleProfileFetch();
Â  Â  Â  }
Â  Â  }
Â  }
Â 
Â  // === ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã®é…å»¶å–å¾—å‡¦ç† ===
Â  function scheduleProfileFetch() {
Â  Â  if (profileFetchTimeout) {
Â  Â  Â  clearTimeout(profileFetchTimeout);
Â  Â  }
Â  Â  profileFetchTimeout = setTimeout(() => {
Â  Â  Â  for (const ws of reactionWSs) {
Â  Â  Â  Â  if (pubkeysToFetchProfile.size > 0 && ws && ws.readyState === WebSocket.OPEN) {
Â  Â  Â  Â  Â  const pubkeys = Array.from(pubkeysToFetchProfile);
Â  Â  Â  Â  Â  const subId = "PROFILE_SUB_ID_REACTIONS_" + Date.now();
Â  Â  Â  Â  Â  ws.send(JSON.stringify(["REQ", subId, {
Â  Â  Â  Â  Â  Â  kinds: [0],
Â  Â  Â  Â  Â  Â  authors: pubkeys,
Â  Â  Â  Â  Â  Â  limit: pubkeys.length
Â  Â  Â  Â  Â  }]));
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  profileFetchTimeout = null;
Â  Â  }, 100);
Â  }
Â 
Â  // === ãƒªãƒ¬ãƒ¼æ¥ç¶šã¨ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­å‡¦ç† ===
Â  function subscribeToReactionRelay() {
Â  Â  reactionWSs.forEach(ws => {
Â  Â  Â  ws.removeEventListener("close", onReactionWSClose);
Â  Â  Â  ws.close();
Â  Â  });
Â  Â  reactionWSs.length = 0;
Â  Â  clearTimeline();
Â 
Â  Â  for (const relayUrl of RELAY_URLS) {
Â  Â  Â  let reactionWS;
Â  Â  Â  try {
Â  Â  Â  Â  reactionWS = new WebSocket(relayUrl);
Â  Â  Â  Â  reactionWSs.push(reactionWS);
Â  Â  Â  } catch (err) {
Â  Â  Â  Â  console.error("Failed to connect to relay:", err);
Â  Â  Â  Â  alert("Failed to connect to relay: " + relayUrl);
Â  Â  Â  Â  continue;
Â  Â  Â  }
Â 
Â  Â  Â  reactionWS.addEventListener("open", function() {
Â  Â  Â  Â  console.log("Connected to relay:", relayUrl);
Â  Â  Â  Â  if (currentTargetPubkeyForReactions) {
Â  Â  Â  Â  Â  reactionWS.send(
Â  Â  Â  Â  Â  Â  JSON.stringify(["REQ", REACTION_SUB_ID, {
Â  Â  Â  Â  Â  Â  Â  kinds: [7],
Â  Â  Â  Â  Â  Â  Â  "#p": [currentTargetPubkeyForReactions],
Â  Â  Â  Â  Â  Â  Â  limit: 50
Â  Â  Â  Â  Â  Â  }])
Â  Â  Â  Â  Â  );
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  loadMoreButton.classList.remove("loading");
Â  Â  Â  Â  }
Â  Â  Â  });
Â 
Â  Â  Â  reactionWS.addEventListener("message", function(ev) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  const r2cMsg = JSON.parse(ev.data);
Â  Â  Â  Â  Â  switch (r2cMsg[0]) {
Â  Â  Â  Â  Â  Â  case "EVENT":
Â  Â  Â  Â  Â  Â  Â  const nostrEv = r2cMsg[2];
Â  Â  Â  Â  Â  Â  Â  if (!window.NostrTools.verifyEvent(nostrEv)) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("nostr event with invalid signature:", nostrEv);
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  onEvent(nostrEv);
Â  Â  Â  Â  Â  Â  Â  break;
Â 
Â  Â  Â  Â  Â  Â  case "EOSE":
Â  Â  Â  Â  Â  Â  Â  if (r2cMsg[1] === REACTION_SUB_ID || r2cMsg[1] === MORE_REACTIONS_SUB_ID) {
Â  Â  Â  Â  Â  Â  Â  Â  loadMoreButton.classList.remove("loading");
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  break;
Â 
Â  Â  Â  Â  Â  Â  case "OK":
Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  case "NOTICE":
Â  Â  Â  Â  Â  Â  Â  console.warn("Relay Notice:", r2cMsg[1]);
Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  default:
Â  Â  Â  Â  Â  Â  Â  console.log(r2cMsg);
Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  console.error(err);
Â  Â  Â  Â  }
Â  Â  Â  });
Â 
Â  Â  Â  reactionWS.addEventListener("close", onReactionWSClose);
Â  Â  }
Â  }
Â 
Â  // === ãƒªãƒ¬ãƒ¼åˆ‡æ–­æ™‚ã®å†æ¥ç¶šå‡¦ç† ===
Â  function onReactionWSClose() {
Â  Â  console.log("Relay connection closed. Attempting to reconnect...");
Â  Â  setTimeout(subscribeToReactionRelay, 5000);
Â  }
Â 
Â  // === NIP-05æ¤œè¨¼é–¢æ•° ===
Â  async function fetchPubkeyFromNip05(nip05) {
Â  Â  const [user, domain] = nip05.split('@');
Â  Â  if (!user || !domain) {
Â  Â  Â  throw new Error("Invalid NIP-05 address format.");
Â  Â  }
Â 
Â  Â  const url = `https://${domain}/.well-known/nostr.json?name=${user}`;
Â 
Â  Â  try {
Â  Â  Â  const response = await fetch(url);
Â  Â  Â  if (!response.ok) {
Â  Â  Â  Â  throw new Error(`Failed to fetch NIP-05 data: ${response.statusText}`);
Â  Â  Â  }
Â 
Â  Â  Â  const data = await response.json();
Â  Â  Â  const pubkey = data.names[user];
Â  Â  Â  if (!pubkey) {
Â  Â  Â  Â  throw new Error(`User "${user}" not found in NIP-05 data.`);
Â  Â  Â  }
Â  Â  Â  return pubkey;
Â  Â  } catch (e) {
Â  Â  Â  console.error("NIP-05 verification failed:", e);
Â  Â  Â  throw e;
Â  Â  }
Â  }
Â 
Â  // ==== ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ====
Â  applyPubkeyForReactionsButton.addEventListener("click", async function() {
Â  Â  const inputVal = targetHexPubkeyInput.value.trim();
Â  Â  let hexPubkey;
Â 
Â  Â  if (inputVal.startsWith("npub1")) {
Â  Â  Â  try {
Â  Â  Â  Â  const { type, data } = window.NostrTools.nip19.decode(inputVal);
Â  Â  Â  Â  if (type === "npub") {
Â  Â  Â  Â  Â  hexPubkey = data;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  throw new Error("Invalid npub key.");
Â  Â  Â  Â  }
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  console.error("Failed to decode npub:", e);
Â  Â  Â  Â  alert("æœ‰åŠ¹ãªnpubå…¬é–‹éµã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
Â  Â  Â  Â  currentTargetPubkeyForReactions = undefined;
Â  Â  Â  Â  clearTimeline();
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  } else if (inputVal.includes("@")) {
Â  Â  Â  try {
Â  Â  Â  Â  hexPubkey = await fetchPubkeyFromNip05(inputVal);
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  alert("æœ‰åŠ¹ãªNIP-05ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
Â  Â  Â  Â  currentTargetPubkeyForReactions = undefined;
Â  Â  Â  Â  clearTimeline();
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  } else if (inputVal.length === 64 && /^[0-9a-fA-F]+$/.test(inputVal)) {
Â  Â  Â  hexPubkey = inputVal;
Â  Â  } else {
Â  Â  Â  alert("æœ‰åŠ¹ãªhexã€npubã€ã¾ãŸã¯NIP-05å…¬é–‹éµã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
Â  Â  Â  currentTargetPubkeyForReactions = undefined;
Â  Â  Â  clearTimeline();
Â  Â  Â  return;
Â  Â  }
Â 
Â  Â  currentTargetPubkeyForReactions = hexPubkey;
Â  Â  console.log("Subscribing reactions for pubkey:", currentTargetPubkeyForReactions);
Â  Â  subscribeToReactionRelay();
Â  });
Â 
Â  const loadMoreButton = document.getElementById("load-more");
Â 
Â  // === ã€Œã‚‚ã£ã¨è¦‹ã‚‹ã€ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© ===
Â  function fetchMoreReactions() {
Â  Â  if (!reactionWSs.some(ws => ws && ws.readyState === WebSocket.OPEN) || !currentTargetPubkeyForReactions) {
Â  Â  Â  console.warn("Relay not connected or no target pubkey set.");
Â  Â  Â  return;
Â  Â  }
Â  Â  loadMoreButton.classList.add("loading");
Â 
Â  Â  const filter = {
Â  Â  Â  kinds: [7],
Â  Â  Â  limit: 50,
Â  Â  Â  until: oldestCreatedAt - 1,
Â  Â  Â  "#p": [currentTargetPubkeyForReactions]
Â  Â  };
Â  Â  for (const ws of reactionWSs) {
Â  Â  Â  if (ws && ws.readyState === WebSocket.OPEN) {
Â  Â  Â  Â  ws.send(JSON.stringify(["REQ", MORE_REACTIONS_SUB_ID, filter]));
Â  Â  Â  }
Â  Â  }
Â  }
Â  loadMoreButton.addEventListener("click", fetchMoreReactions);
Â 
Â  // === åˆæœŸåŒ–å‡¦ç† ===
Â  document.addEventListener("DOMContentLoaded", function() {
Â  Â  // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«è‡ªå‹•ã§ãƒªãƒ¬ãƒ¼ã«æ¥ç¶š
Â  Â  subscribeToReactionRelay();
Â  });
</script>
<script src="https://ompomz.github.io/header/loadHeader.js"></script>
</body>
</html>
