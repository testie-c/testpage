<!DOCTYPE html>
<html lang="ja">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>want peek you</title>
 <style>
 body { font-family: sans-serif; max-width: 800px; margin: auto; padding: 20px; line-height: 1.6; }
 h4, h5 { color: #333; }
 label { display: block; margin-top: 10px; font-weight: bold; }
 input[type="text"], textarea, select { width: 100%; padding: 8px; margin-top: 5px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
 button { padding: 10px 15px; margin-top: 10px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; }
 button:hover { background-color: #0056b3; }
 .flex-container { display: flex; gap: 20px; }
 .flex-item { flex: 1; }
 pre { background-color: #f4f4f4; padding: 10px; border: 1px solid #ddd; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; }
 #log { margin-top: 20px; padding: 10px; background-color: #e9e9e9; border: 1px solid #ddd; height: 150px; overflow-y: scroll; }
 </style>
</head>
<body>
 <div id="header-placeholder"></div>
 <script src="https://ompomz.github.io/header/loadHeader.js"></script>
 <h4>want peek you</h4><span>Nostr kind:30000 Event Manager</span>
 <div id="loader" style="display:none; text-align:center;">
 <p>処理中...</p>
 </div>
 <label for="npubInput">npubを入力:</label>
 <input type="text" id="npubInput" placeholder="npub1..." value="">
 <button onclick="fetchEvents()">イベントを取得</button> 
 <label for="dTagSelect">編集するリストを選択:</label>
 <select id="dTagSelect" disabled>
 <option value="">dタグを選択してください</option>
 </select> 
 <label for="nsecInput">nsecを入力:</label>
 <input type="text" id="nsecInput" placeholder="nsec1..." value="">
 <button onclick="decryptContent()" id="decryptButton" disabled>復号</button>
 <div class="flex-container">
 <div class="flex-item">
 <label for="contentInput">① 暗号化する公開鍵 (content):</label>
 <textarea id="contentInput" rows="5" placeholder="公開鍵をhex形式で入力 (改行、カンマ、スペース区切り)"></textarea>
 </div>
 <div class="flex-item">
 <label for="pTagsInput">② pタグに含める公開鍵:</label>
 <textarea id="pTagsInput" rows="5" placeholder="公開鍵をhex形式で入力 (改行、カンマ、スペース区切り)"></textarea>
 </div>
 </div>
 <button onclick="generateEvent()" id="generateButton">JSONを生成</button>
 <h5>生成されたJSON</h5>
 <pre id="generatedJson" style="min-height: 100px;"></pre>
 <button onclick="updateEvent()" id="updateButton" disabled>更新</button>
 <h5>ログ</h5>
 <div id="log"></div>
<script src="https://unpkg.com/nostr-tools/lib/nostr.bundle.js"></script>
<script>
  const {
    getPublicKey,
    nip19,
    finalizeEvent,
    nip04
  } = window.NostrTools;

  const relayUrl = 'wss://relay.nostr.band';

  let userNsec = '';
  let userPubkey = '';
  let currentEvent = null;
  let originalPubkeysFromPtag = [];
  let originalDtag = '';

  const npubInput = document.getElementById('npubInput');
  const nsecInput = document.getElementById('nsecInput');
  const dTagSelect = document.getElementById('dTagSelect');
  const contentInput = document.getElementById('contentInput');
  const pTagsInput = document.getElementById('pTagsInput');
  const generatedJsonPre = document.getElementById('generatedJson');
  const logDiv = document.getElementById('log');
  const decryptButton = document.getElementById('decryptButton');
  const generateButton = document.getElementById('generateButton');
  const updateButton = document.getElementById('updateButton');
  const loader = document.getElementById('loader');

  function showLoader() {
    loader.style.display = 'block';
  }

  function hideLoader() {
    loader.style.display = 'none';
  }

  function log(message, type = 'info') {
    const entry = document.createElement('p');
    entry.textContent = message;
    if (type === 'error') {
      entry.style.color = 'red';
    } else if (type === 'success') {
      entry.style.color = 'green';
    }
    logDiv.prepend(entry);
  }

  function parsePubkeys(input) {
    return input.split(/[\n, \t]+/).map(key => key.trim()).filter(key => key.length === 64);
  }

  function fetchEvents() {
    showLoader();
    dTagSelect.innerHTML = '<option value="">dタグを選択してください</option>';
    dTagSelect.disabled = !0;
    decryptButton.disabled = !0;

    const npub = npubInput.value;
    if (!npub) {
      log('npubを入力してください。', 'error');
      hideLoader();
      return;
    }

    try {
      const {
        data: pubkey
      } = nip19.decode(npub);
      const socket = new WebSocket(relayUrl);
      const events = [];

      socket.onopen = () => {
        log('WebSocket接続成功');
        const subscriptionId = "kind30000_sub";
        const filter = {
          kinds: [30000],
          authors: [pubkey]
        };
        socket.send(JSON.stringify(["REQ", subscriptionId, filter]));
      };

      socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data[0] === "EVENT") {
          events.push(data[2]);
        }
        if (data[0] === "EOSE") {
          socket.close();
          log('イベント取得完了。WebSocketを閉じます。');
          if (events.length === 0) {
            log('kind:30000のイベントが見つかりませんでした。', 'error');
          } else {
            events.forEach(event => {
              const dTag = event.tags.find(tag => tag[0] === 'd');
              if (dTag) {
                const option = document.createElement('option');
                option.value = JSON.stringify(event);
                option.textContent = dTag[1];
                dTagSelect.appendChild(option);
              }
            });
            dTagSelect.disabled = !1;
            decryptButton.disabled = !1;
            log(`${events.length}件のイベントを取得しました。`);
          }
          hideLoader();
        }
      };

      socket.onerror = (err) => {
        log('WebSocketエラー: ' + err.message, 'error');
        hideLoader();
      };

      socket.onclose = () => {
        log('WebSocket接続を閉じました。');
        hideLoader();
      };
    } catch (error) {
      log('イベント取得中にエラーが発生しました: ' + error.message, 'error');
      hideLoader();
    }
  }

  async function decryptContent() {
    showLoader();
    try {
      const selectedEventJson = dTagSelect.value;
      if (!selectedEventJson) {
        log('イベントを選択してください。', 'error');
        hideLoader();
        return;
      }
      currentEvent = JSON.parse(selectedEventJson);
      const nsec = nsecInput.value;
      if (!nsec) {
        log('nsecを入力してください。', 'error');
        hideLoader();
        return;
      }
      const {
        data: privkey
      } = nip19.decode(nsec);
      userNsec = privkey;
      userPubkey = getPublicKey(userNsec);

      const pubkeyFromEvent = currentEvent.pubkey;
      if (userPubkey !== pubkeyFromEvent) {
        log('入力されたnsecは、このイベントの公開鍵と一致しません。', 'error');
        hideLoader();
        return;
      }

      originalPubkeysFromPtag = currentEvent.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]);
      originalDtag = currentEvent.tags.find(tag => tag[0] === 'd')[1];

      if (originalPubkeysFromPtag.length === 0) {
        log('pタグが見つからないため復号できません。', 'error');
        hideLoader();
        return;
      }

      const pubkeyForDecryption = originalPubkeysFromPtag[0];
      const decryptedContent = await nip04.decrypt(privkey, pubkeyForDecryption, currentEvent.content);
      const decryptedData = JSON.parse(decryptedContent);
      const pubkeys = decryptedData.map(tag => tag[1]);
      contentInput.value = pubkeys.join('\n');
      pTagsInput.value = originalPubkeysFromPtag.join('\n');
      log('イベントを正常に復号しました。');
      generateButton.disabled = !1;
    } catch (error) {
      log('復号中にエラーが発生しました: ' + error.message, 'error');
    } finally {
      hideLoader();
    }
  }

  async function generateEvent() {
    showLoader();
    try {
      if (!userNsec || !userPubkey) {
        log('まずイベントを復号してください。', 'error');
        hideLoader();
        return;
      }

      const newContentPubkeys = parsePubkeys(contentInput.value);
      const newPTagsPubkeys = parsePubkeys(pTagsInput.value);

      if (newContentPubkeys.length === 0 || newPTagsPubkeys.length === 0) {
        log('contentまたはpタグに含める公開鍵を入力してください。', 'error');
        hideLoader();
        return;
      }

      const contentTags = newContentPubkeys.map(pubkey => ["p", pubkey]);
      const encryptedContent = await nip04.encrypt(userNsec, newPTagsPubkeys[0], JSON.stringify(contentTags));

      const event = {
        kind: 30000,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ['d', originalDtag],
          ...newPTagsPubkeys.map(pubkey => ['p', pubkey]),
        ],
        content: encryptedContent,
      };

      const signedEvent = finalizeEvent(event, userNsec);
      generatedJsonPre.textContent = JSON.stringify(signedEvent, null, 2);
      log('JSONイベントを生成しました。');
      updateButton.disabled = !1;
    } catch (error) {
      log('JSON生成中にエラーが発生しました: ' + error.message, 'error');
    } finally {
      hideLoader();
    }
  }

  async function updateEvent() {
    showLoader();
    try {
      const event = JSON.parse(generatedJsonPre.textContent);
      const socket = new WebSocket(relayUrl);

      socket.onopen = () => {
        log('イベント公開のためのWebSocket接続成功');
        socket.send(JSON.stringify(["EVENT", event]));
      };

      socket.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data[0] === "OK") {
          if (data[2]) {
            log('イベントは正常に公開されました！', 'success');
          } else {
            log('イベントの公開に失敗しました: ' + data[3], 'error');
          }
          socket.close();
        }
      };

      socket.onerror = (err) => {
        log('イベント公開時のWebSocketエラー: ' + err.message, 'error');
        socket.close();
        hideLoader();
      };
    } catch (error) {
      log('イベント更新中にエラーが発生しました: ' + error.message, 'error');
    } finally {
      hideLoader();
    }
  }
</script>
</body>
</html>
