<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>削除ツール</title>
  <script src="https://unpkg.com/nostr-tools@1.17.0/lib/nostr.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 600px; margin: auto; }
    input, textarea, button { width: 100%; margin: 10px 0; padding: 8px; }
    label { font-weight: bold; margin-top: 15px; display: block; }
    .success { color: green; }
    .error { color: red; }
    #eventJsonPreview { white-space: pre-wrap; background: #f0f0f0; padding: 10px; margin-top: 10px; }
  </style>
</head>
<body>
  <label for="noteId">削除対象のNote ID（note1... または nevent1...）</label>
  <input type="text" id="noteId" placeholder="例: note1xyz..." />
  <label for="privateKeyHex">秘密鍵（nsec形式またはhex形式）</label>
  <input type="text" id="privateKeyHex" placeholder="例: nsec1abc... または f1a2b3..." />
  <label for="relays">リレーURL（改行区切りで複数可）</label>
  <textarea id="relays" rows="4" placeholder="例:\nwss://relay.damus.io\nwss://nostr-relay.example"></textarea>
  <button id="createJsonButton">削除イベントを生成</button>
  <button id="signAndSendButton" disabled>署名して送信</button>
  <div id="eventJsonPreview"></div>
  <div id="results"></div>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const { nip19, getPublicKey, getEventHash, schnorr } = NostrTools;

      const noteIdInput = document.getElementById('noteId');
      const relaysInput = document.getElementById('relays');
      const privateKeyHexInput = document.getElementById('privateKeyHex');
      const createJsonButton = document.getElementById('createJsonButton');
      const signAndSendButton = document.getElementById('signAndSendButton');
      const eventJsonPreview = document.getElementById('eventJsonPreview');
      const resultsDiv = document.getElementById('results');

      let eventToSign = null;

      async function finalizeEvent(event, privkey) {
        event.id = getEventHash(event);
        event.sig = await schnorr.sign(event.id, privkey);
        return event;
      }

      createJsonButton.addEventListener('click', async () => {
        resultsDiv.innerHTML = '';
        const noteId = noteIdInput.value.trim();
        let privkeyInput = privateKeyHexInput.value.trim();

        if (!noteId || !privkeyInput) {
          resultsDiv.innerHTML = '<span class="error">Note IDと秘密鍵をすべて入力してください。</span>';
          return;
        }

        try {
          if (privkeyInput.startsWith('nsec')) {
            privkeyInput = nip19.decode(privkeyInput).data;
          }

          const { type, data } = nip19.decode(noteId);
          if (type !== 'note' && type !== 'nevent') {
            throw new Error('無効なNote IDです。');
          }

          const eventId = typeof data === 'string' ? data : data.id;
          const pubkey = getPublicKey(privkeyInput);

          eventToSign = {
            kind: 5,
            created_at: Math.floor(Date.now() / 1000),
            tags: [['e', eventId]],
            content: 'Note deleted by user.',
            pubkey: pubkey,
          };

          const finalEvent = await finalizeEvent(eventToSign, privkeyInput);
          eventJsonPreview.textContent = JSON.stringify(finalEvent, null, 2);
          signAndSendButton.disabled = false;
          resultsDiv.innerHTML = '<span class="success">✅ JSONが作成されました。内容を確認し、「署名して送信」ボタンを押してください。</span>';
        } catch (e) {
          eventJsonPreview.textContent = '';
          signAndSendButton.disabled = true;
          resultsDiv.innerHTML = `<span class="error">⚠️ エラー: ${e.message}</span>`;
        }
      });

      signAndSendButton.addEventListener('click', async () => {
        if (!eventToSign) {
          resultsDiv.innerHTML = '<span class="error">先にJSONを作成してください。</span>';
          return;
        }

        signAndSendButton.disabled = true;
        resultsDiv.innerHTML = '送信中...';

        const relays = relaysInput.value.trim().split('\n').filter(url => url.startsWith('wss://') || url.startsWith('ws://'));
        let privkeyInput = privateKeyHexInput.value.trim();
        if (privkeyInput.startsWith('nsec')) {
          privkeyInput = nip19.decode(privkeyInput).data;
        }

        if (relays.length === 0) {
          resultsDiv.innerHTML = '<span class="error">有効なリレーURLが入力されていません。</span>';
          signAndSendButton.disabled = false;
          return;
        }

        const event = await finalizeEvent(eventToSign, privkeyInput);
        resultsDiv.innerHTML = '';

        for (const relayUrl of relays) {
          const relayResultDiv = document.createElement('div');
          relayResultDiv.innerHTML = `<h3>${relayUrl}</h3>`;
          resultsDiv.appendChild(relayResultDiv);

          try {
            const ws = new WebSocket(relayUrl);
            ws.onopen = () => {
              relayResultDiv.innerHTML += '<p>接続成功。イベントを送信中...</p>';
              ws.send(JSON.stringify(['EVENT', event]));
            };
            ws.onmessage = (message) => {
              const msg = JSON.parse(message.data);
              if (msg[0] === 'OK') {
                const [ok, eventId, success, reason] = msg;
                if (success) {
                  relayResultDiv.innerHTML += `<p class="success">✅ <b>送信成功:</b> ${reason || ''}</p>`;
                } else {
                  relayResultDiv.innerHTML += `<p class="error">❌ <b>送信失敗:</b> ${reason || '不明なエラー'}</p>`;
                }
              }
              ws.close();
            };
            ws.onerror = (e) => {
              relayResultDiv.innerHTML += `<p class="error">❌ 接続エラー: ${e.message}</p>`;
              ws.close();
            };
            ws.onclose = () => {
              relayResultDiv.innerHTML += '<hr>';
            };
          } catch (e) {
            relayResultDiv.innerHTML += `<p class="error">❌ 接続または送信中にエラーが発生しました: ${e.message}</p><hr>`;
          }
        }

        signAndSendButton.disabled = false;
      });
    });
  </script>
</body>
</html>
